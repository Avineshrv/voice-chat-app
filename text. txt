// index.tsx
import React, {
  useCallback,
  useEffect,
  useRef,
  useState,
  ForwardedRef,
} from 'react';
import debounce from 'lodash/debounce';
import classNames from 'classnames';
import styles from './searchInput.module.scss';
import { GradientSearch, XCircle } from 'sc-nitro-icons';

export type SearchInputProps = {
  value: string;
  onChange?: (value: string) => void;
  onClear?: () => void;
  placeholder?: string[]; // rotation placeholders
  roundedCorner?: boolean;
  onSearch?: (searchValue: string) => void;
  debounceDelay?: number; // ms
  animationDuration?: number; // placeholder rotation ms
  id?: string;
  name?: string;
  ariaLabel?: string;
  className?: string;
};

/**
 * SearchInput component (controlled).
 * - onChange called immediately on every keystroke.
 * - onSearch called only after `debounceDelay` ms of inactivity (or immediately on Enter).
 */
const SearchInput = React.forwardRef(function SearchInput(
  {
    value,
    onChange,
    onClear,
    placeholder = ['Search...'],
    roundedCorner = false,
    onSearch,
    debounceDelay = 300,
    animationDuration = 1000,
    id = 'searchInput',
    name,
    ariaLabel = 'Search',
    className,
  }: SearchInputProps,
  forwardedRef: ForwardedRef<HTMLInputElement>
) {
  // placeholder rotation
  const [currentPlaceholder, setCurrentPlaceholder] = useState(
    placeholder[0] ?? ''
  );
  const [placeholderIndex, setPlaceholderIndex] = useState(0);

  // input ref (allow parent ref via forwardRef)
  const inputRef = useRef<HTMLInputElement | null>(null);
  // merge forwarded ref
  useEffect(() => {
    if (!forwardedRef) return;
    if (typeof forwardedRef === 'function') {
      forwardedRef(inputRef.current);
    } else {
      // @ts-ignore assign
      forwardedRef.current = inputRef.current;
    }
  }, [forwardedRef]);

  // debounced search stored in ref so we can cancel it reliably
  const debouncedRef = useRef<ReturnType<typeof debounce> | null>(null);

  // create/update debounced function whenever onSearch or debounceDelay changes
  useEffect(() => {
    // create new debounced function that calls latest onSearch
    const handler = debounce((v: string) => {
      onSearch?.(v);
    }, debounceDelay);

    // set into ref and cleanup previous handler by returning cancel
    debouncedRef.current = handler;
    return () => {
      handler.cancel();
    };
  }, [onSearch, debounceDelay]);

  // ensure we cancel any pending debounced call when component unmounts
  useEffect(() => {
    return () => {
      debouncedRef.current?.cancel();
    };
  }, []);

  // when input changes -> call onChange and schedule debounced search
  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const newValue = e.target.value;
      onChange?.(newValue);
      debouncedRef.current?.(newValue); // schedule debounced onSearch
    },
    [onChange]
  );

  // on Enter -> cancel debounce and fire search immediately
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (e.key === 'Enter') {
        debouncedRef.current?.cancel();
        onSearch?.(value);
      }
    },
    [onSearch, value]
  );

  // clear button behaviour
  const handleClear = useCallback(() => {
    debouncedRef.current?.cancel();
    onChange?.('');
    onClear?.();
    // keep focus for keyboard users
    inputRef.current?.focus();
  }, [onChange, onClear]);

  // placeholder rotation logic
  useEffect(() => {
    setCurrentPlaceholder(placeholder[placeholderIndex] ?? '');
  }, [placeholderIndex, placeholder]);

  useEffect(() => {
    if (!placeholder || placeholder.length <= 1) return;
    const interval = setInterval(() => {
      setPlaceholderIndex((prev) => (prev + 1) % placeholder.length);
    }, animationDuration);
    return () => clearInterval(interval);
  }, [placeholder, animationDuration]);

  return (
    <div
      className={classNames(
        styles.searchInputContainer,
        roundedCorner ? styles.fullyRounded : styles.halfRounded,
        className
      )}
      // expose animation duration CSS variable if needed by styles module
      style={{ ['--animation-duration' as any]: `${animationDuration}ms` } as React.CSSProperties}
    >
      <label
        className={classNames(styles.animatedLabel, value && styles.activeLabel)}
        htmlFor={id}
      >
        <span>{currentPlaceholder}</span>
      </label>

      <input
        id={id}
        name={name}
        ref={inputRef}
        className={classNames(styles.inputField)}
        type="text"
        value={value}
        onChange={handleInputChange}
        onKeyDown={handleKeyDown}
        aria-label={ariaLabel}
        autoComplete="off"
      />

      {/* icon / clear button */}
      {value ? (
        <button
          type="button"
          className={styles.iconButton}
          onClick={handleClear}
          aria-label="Clear search"
        >
          <XCircle color="#282828" />
        </button>
      ) : (
        <span className={styles.icon} aria-hidden>
          <GradientSearch />
        </span>
      )}
    </div>
  );
});

export default React.memo(SearchInput);




// searchInput.stories.tsx
import React, { useState } from 'react';
import { Meta, StoryFn } from '@storybook/react';
import SearchInput, { SearchInputProps } from './index';

export default {
  title: 'Components/SearchInput/DebounceDemo',
  component: SearchInput,
  argTypes: {
    debounceDelay: { control: 'number' },
    animationDuration: { control: 'number' },
  },
} as Meta;

export const DebounceDemo: StoryFn<SearchInputProps> = (args) => {
  const [value, setValue] = useState('');
  const [apiCalls, setApiCalls] = useState(0);

  // this simulates an API call — increment counter on each actual onSearch call
  const handleSearch = (v: string) => {
    setApiCalls((c) => c + 1);
    console.log('Simulated API call with:', v);
  };

  return (
    <div style={{ padding: 20, maxWidth: 480 }}>
      <h3>Debounce demo</h3>
      <p style={{ marginTop: 0 }}>
        Type fast — <strong>onChange</strong> will run for every character, but{' '}
        <strong>onSearch</strong> (simulated API call) only runs after debounceDelay
        ms of inactivity or when you press Enter.
      </p>

      <SearchInput
        {...args}
        value={value}
        onChange={setValue}
        onSearch={handleSearch}
        placeholder={['Search toys', 'Search characters', 'Search products']}
      />

      <div style={{ marginTop: 12 }}>
        <strong>API calls:</strong> {apiCalls}{' '}
        <button style={{ marginLeft: 8 }} onClick={() => setApiCalls(0)}>
          Reset
        </button>
      </div>
    </div>
  );
};

DebounceDemo.args = {
  debounceDelay: 500,
  animationDuration: 2000,
};